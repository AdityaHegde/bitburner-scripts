import type { InfiltrationSolverFunction } from "$src/exploits/infiltration/solvers/keyCodes";
import { KeyCodes } from "$src/exploits/infiltration/solvers/keyCodes";
import type { InfiltrationMocks } from "$src/exploits/infiltration/InfiltrationMocks";

export const matchSymbols: InfiltrationSolverFunction = async (
  mocks: InfiltrationMocks,
  infiltrationBody: HTMLElement,
) => {
  const targets = new Array<string>();
  for (const target of infiltrationBody.querySelector("h5").children) {
    targets.push(target.textContent.trim());
  }

  const box = infiltrationBody.querySelector(".MuiBox-root");
  const [, , map] = parseGrid(box);

  let x = 0;
  let y = 0;

  for (let i = 0; i < targets.length && infiltrationBody.isConnected; i++) {
    const [tarX, tarY] = map.get(targets[i]);

    await gotoCoordinate(mocks, x, tarX, KeyCodes.LEFT_ARROW, KeyCodes.RIGHT_ARROW);
    x = tarX;
    await gotoCoordinate(mocks, y, tarY, KeyCodes.UP_ARROW, KeyCodes.DOWN_ARROW);
    y = tarY;
    await mocks.enterKey(KeyCodes.SPACE);
  }
};

function parseGrid(box: Element): [number, Array<Array<string>>, Map<string, [number, number]>] {
  const size = Math.sqrt(box.children.length);
  const grid = new Array<Array<string>>(size).fill([]).map(() => new Array<string>(size));
  const map = new Map<string, [number, number]>();

  for (let i = 0; i < box.children.length; i++) {
    const x = i % size;
    const y = Math.floor(i / size);
    const label = box.children[i].textContent.trim();
    grid[y][x] = label;
    map.set(label, [x, y]);
  }

  return [size, grid, map];
}

async function gotoCoordinate(
  mocks: InfiltrationMocks,
  from: number,
  to: number,
  decrementKey: string,
  incrementKey: string,
) {
  if (from === to) return;

  const key = from > to ? decrementKey : incrementKey;
  const min = Math.min(from, to);
  const max = Math.max(from, to);

  for (let i = min; i < max; i++) {
    await mocks.enterKey(key);
  }
}
