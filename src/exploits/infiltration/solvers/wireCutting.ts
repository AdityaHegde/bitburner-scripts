import type { InfiltrationSolverFunction } from "$src/exploits/infiltration/solvers/keyCodes";
import type { InfiltrationMocks } from "$src/exploits/infiltration/InfiltrationMocks";

const RowsCount = 9;
const Colors = { red: "red", "rgb(255, 193, 7)": "yellow", blue: "blue", white: "white" };

export const wireCutting: InfiltrationSolverFunction = async (
  mocks: InfiltrationMocks,
  infiltrationBody: HTMLElement,
) => {
  const questions = getQuestion(infiltrationBody);
  const wires = getWires(infiltrationBody);

  const wiresCut = new Set<string>();
  const cutWire = (wire) => {
    if (wiresCut.has(wire)) return;
    wiresCut.add(wire);
    return mocks.enterKey(wire);
  };

  for (const [type, question] of questions) {
    if (type) {
      for (let i = 0; i < wires.length; i++) {
        if (!wires[i].has(question)) continue;
        await cutWire("" + (i + 1));
      }
    } else {
      await cutWire(question);
    }
  }
};

function getWires(infiltrationBody: HTMLElement) {
  const box = infiltrationBody.querySelector(".MuiBox-root");
  const wireCount = box.children.length / RowsCount;
  const wires = new Array<Set<string>>(wireCount).fill(undefined).map(() => new Set());

  for (let i = wireCount; i < box.children.length; i++) {
    const wire = i % wireCount;
    wires[wire].add(Colors[(box.children[i] as HTMLElement).style.color]);
  }

  return wires;
}

function getQuestion(infiltrationBody: HTMLElement) {
  const questions = new Array<[boolean, string]>();
  for (const child of infiltrationBody.children) {
    if (!child.textContent.startsWith("Cut")) continue;

    const numberMatch = /Cut wires number (\d+)\./.exec(child.textContent);
    if (numberMatch) {
      questions.push([false, numberMatch[1]]);
      continue;
    }

    const colorMatch = /Cut all wires colored (\w+)./.exec(child.textContent);
    if (colorMatch) {
      questions.push([true, colorMatch[1]]);
    }
  }
  return questions;
}
