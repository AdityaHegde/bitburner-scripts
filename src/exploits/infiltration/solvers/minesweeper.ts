import { asyncWait } from "$server/utils/asyncUtils";
import type { InfiltrationSolverFunction } from "$src/exploits/infiltration/solvers/keyCodes";
import { KeyCodes } from "$src/exploits/infiltration/solvers/keyCodes";
import type { InfiltrationMocks } from "$src/exploits/infiltration/InfiltrationMocks";

export const minesweeper: InfiltrationSolverFunction = async (
  mocks: InfiltrationMocks,
  infiltrationBody: HTMLElement,
) => {
  const box = infiltrationBody.querySelector(".MuiBox-root");
  const [size, grid, mines] = parseGrid(box);
  let markedMines = mines;

  const title = infiltrationBody.querySelector("h4");
  while (title.textContent !== "Mark all the mines!") {
    await asyncWait(100);
  }

  for (let y = 0; y < size && markedMines > 0; y++) {
    for (let x = 0; x < size && markedMines > 0; x++) {
      if (grid[y][x]) {
        await mocks.enterKey(KeyCodes.SPACE);
        markedMines--;
      }
      await mocks.enterKey(KeyCodes.RIGHT_ARROW);
    }
    await mocks.enterKey(KeyCodes.DOWN_ARROW);
  }
};

function parseGrid(box: Element): [number, Array<Array<boolean>>, number] {
  const size = Math.sqrt(box.children.length);
  const grid = new Array<Array<boolean>>(size)
    .fill([])
    .map(() => new Array<boolean>(size).fill(false));
  let mines = 0;

  for (let i = 0; i < box.children.length; i++) {
    const x = i % size;
    const y = Math.floor(i / size);
    if (box.children[i].children.length) {
      grid[y][x] = true;
      mines++;
    }
  }

  return [size, grid, mines];
}
