import type { NS } from "$src/types/gameTypes";
import { clickNav, gotoLocation } from "$src/automation/exploits/goto";
import { clickButtonWithText, setInputValue } from "$src/automation/exploits/interactions";
import { WHRNG } from "$src/exploits/casino/WHRNG";
import { MaxCasinoProfit } from "$src/exploits/casino/coinFlip";
import { doc } from "$src/automation/exploits/references";
import { asyncWait } from "$server/utils/asyncUtils";

const MaxBet = 1e7;

export async function roulette(ns: NS) {
  await gotoLocation("Â¢", 1);

  // mock Date.getTime to make sure RNG is predictable
  const originalDateGetTime = Date.prototype.getTime;
  Date.prototype.getTime = () => 1000;
  await clickButtonWithText("Play roulette");
  Date.prototype.getTime = originalDateGetTime;

  // mock Math.random to break the cheating :)
  const originalMathRandom = Math.random;
  Math.random = () => 0.5;

  await playRoulette(ns);

  Math.random = originalMathRandom;

  await clickNav("Terminal");
}

async function playRoulette(ns: NS) {
  const rng = new WHRNG(1000);

  let sources = ns.getMoneySources();
  while (sources.sinceInstall.casino < MaxCasinoProfit) {
    const player = ns.getPlayer();
    await setInputValue("number", Math.min(player.money, MaxBet) + "");

    const num = Math.floor(rng.random() * 37);
    await clickButtonWithText(num + "");

    if (await waitForResult()) break;
    sources = ns.getMoneySources();
  }
}

async function waitForResult() {
  let failed = false;
  let done = false;

  while (!done) {
    await asyncWait(500);
    const lost = doc.evaluate("//h4[contains(text(),'lost')]", doc).iterateNext();
    if (lost) {
      // possible issue with rng
      failed = true;
      break;
    }

    const won = doc.evaluate("//h4[contains(text(),'won')]", doc).iterateNext();
    if (won) done = true;
  }

  return failed;
}
